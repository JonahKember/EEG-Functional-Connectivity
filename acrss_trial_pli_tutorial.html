
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Across-trial phase-lag index: tutorial</title><meta name="generator" content="MATLAB 9.12"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2023-01-28"><meta name="DC.source" content="acrss_trial_pli_tutorial.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>Across-trial phase-lag index: tutorial</h1><!--introduction--><p>The following is a step-by-step tutorial demonstrating how the function 'across_trial_pli.m' is implemented.</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Generate pseudo EEG data.</a></li><li><a href="#4">Create filter.</a></li><li><a href="#6">Apply filter, estimate instantaneous phase.</a></li><li><a href="#9">Implement the across-trial phase-lag index.</a></li></ul></div><h2 id="1">Generate pseudo EEG data.</h2><p>First, we will create pseudo-random EEG data. This data will be event-related (70 trials, 64 channels, 6000 samples per trial at a sampling rate of 1000Hz). Each channel time-series will be a weighted combination of pink noise (i.e., 1/f) and two sinusoids (10Hz and 25Hz), where the phase of each sinusoid is drawn uniformly at random from -pi to pi.</p><pre class="codeinput"><span class="comment">% Define the dimensions of the data.</span>
n_channels = 64;
n_samples = 6000;
n_trials = 70;
samp_rate = 1000;

<span class="comment">% Define the frequencies and weights of the sinusoids.</span>
peaks = [];
peaks.hz = [10,25];
peaks.w = [.1,.05];

<span class="comment">% Define the amount of noise.</span>
noise = 3;

<span class="comment">% Set seed for reproducibility</span>
rng(1)

xs = [];
xs.raw = zeros(n_channels,n_samples,n_trials);
time = 0:(1/samp_rate):(n_samples/samp_rate)-(1/samp_rate);

<span class="keyword">for</span> trial = 1:n_trials
    <span class="keyword">for</span> channel = 1:n_channels
        sine_1 = sin(2*pi*peaks.hz(1)*time + rand(1)*pi);
        sine_2 = sin(2*pi*peaks.hz(2)*time + rand(1)*pi);
        xs.raw(channel,:,trial) = peaks.w(1)*sine_1 + peaks.w(2)*sine_2;
    <span class="keyword">end</span>
    xs.raw(:,:,trial) = xs.raw(:,:,trial) + noise*pinknoise(n_samples,n_channels)';
<span class="keyword">end</span>
</pre><p>Let's have a look at the time-series of a single channel to ensure everything worked.</p><pre class="codeinput"><span class="comment">% Plot a single channel time-series.</span>

figure(<span class="string">'Position'</span>,[505 428 895 369]);
plot(xs.raw(1,:,1),<span class="string">'k'</span>);
xlim([650,1650])
ylim([-.5,.5])
xlabel(<span class="string">'Time'</span>)
ylabel(<span class="string">'Voltage ({\mu}V)'</span>)
title(<span class="string">'Single channel time-series'</span>)
set(gca,<span class="string">'XTick'</span>,[], <span class="string">'YTick'</span>, [])
</pre><img vspace="5" hspace="5" src="acrss_trial_pli_tutorial_01.png" alt=""> <p>Let's inpsect the power spectral density of said time-series as well, to ensure that the oscillations we created are present as peaks. With real data, I suggest parameterizing this power spectrum to assess the characteristics of any peaks that exist within the data prior to implementing these analyses. See, for example: <a href="https://fooof-tools.github.io/fooof/">https://fooof-tools.github.io/fooof/</a></p><pre class="codeinput">[~,freq,~,psd] = spectrogram(xs.raw(1,:,1),samp_rate,[],[],samp_rate);
mean_psd = mean(psd,2);

figure(<span class="string">'Position'</span>,[576 479 678 309]);
plot(freq,mean_psd,<span class="string">'k'</span>)
title(<span class="string">'Power spectral density'</span>)
xlim([0,50])
ylim([0,.005])
xlabel(<span class="string">'Hz'</span>)
ylabel(<span class="string">'Power ({\mu}V{^2}/Hz)'</span>)
xline(peaks.hz,<span class="string">'--'</span>,<span class="string">'color'</span>,<span class="string">'red'</span>)
legend(<span class="string">'PSD'</span>,<span class="string">'Peaks'</span>)
</pre><img vspace="5" hspace="5" src="acrss_trial_pli_tutorial_02.png" alt=""> <h2 id="4">Create filter.</h2><p>Now, let's create a band-pass filter so we can estimate the instantaneous phase of the oscillation at 10Hz. I'll use a window from 5-15Hz for this filter. However, visual inspection, as well as careful consideration of the research question (in terms of time/frequency resolution trade-off) is crucial in selecting this parameter. In an ideal world, the sensitivity of any results to a range of filter widths would be assessed.</p><pre class="codeinput">filt_band = [5 15];

filt_params = [];

filt_params.transition = mean(filt_band) * 0.2;
filt_params.frequencies = [filt_band(1) - filt_params.transition, filt_band(1), filt_band(2), filt_band(2) + filt_params.transition];
filt_params.order = kaiserord(filt_params.frequencies, [0 1 0], [0.1 0.05 0.1], samp_rate);
filt_params.coefficients = fir1(filt_params.order, filt_band*(2/samp_rate), <span class="string">'bandpass'</span>);
</pre><p>The parameters of the filter are stored in the structure 'filt_params', shown here:</p><pre class="codeinput">disp(filt_params)
</pre><pre class="codeoutput">      transition: 2
     frequencies: [3 5 15 17]
           order: 630
    coefficients: [-4.3094e-05 -4.3982e-05 -4.4236e-05 -4.3866e-05 &#8230; ]

</pre><h2 id="6">Apply filter, estimate instantaneous phase.</h2><p>Now that we've created the filter, let's apply it and calculate the instantaenous phase of the time-series using the Hilbert transform. First, we will Z-score each channel time-series, then filter, then calculate the instantaneous phase.</p><pre class="codeinput">tic
<span class="keyword">for</span> trial = 1:n_trials

    xs.norm(:,:,trial) = zscore(xs.raw(:,:,trial)')';

    <span class="keyword">for</span> channel = 1:n_channels
        xs.filtered(channel,:,trial)  = filtfilt(filt_params.coefficients, 1, squeeze(xs.norm(channel,:,trial)));
    <span class="keyword">end</span>

    xs.hilbert(:,:,trial) = hilbert(xs.filtered(:,:,trial));
    xs.phase(:,:,trial) = angle(xs.hilbert(:,:,trial));

<span class="keyword">end</span>
toc
</pre><pre class="codeoutput">Elapsed time is 29.720960 seconds.
</pre><p>The structure 'xs' (time-series) includes all the intermediate processing steps: the raw signals, the z-scored signals, the band-pass filtered signals, the hilbert-transformed signals, and the instantaneous phase signals.</p><pre class="codeinput">disp(xs)
</pre><pre class="codeoutput">         raw: [64&times;6000&times;70 double]
        norm: [64&times;6000&times;70 double]
    filtered: [64&times;6000&times;70 double]
     hilbert: [64&times;6000&times;70 double]
       phase: [64&times;6000&times;70 double]

</pre><p>Let's plot the raw signal against the band-pass filtered signal to ensure everything worked correctly.</p><pre class="codeinput">figure(<span class="string">'Position'</span>,[505 428 895 369]);
plot(zscore(xs.raw(1,:,1)),<span class="string">'k'</span>)
hold <span class="string">on</span>;plot(zscore(xs.filtered(1,:,1)),<span class="string">'color'</span>,<span class="string">'red'</span>)
xlim([650,1650])
title(<span class="string">'Raw vs. band-pass filtered signal'</span>)
legend(<span class="string">'Raw'</span>,<span class="string">'Filtered'</span>)
xlabel(<span class="string">'Sample'</span>)
ylabel(<span class="string">'Voltage ({\mu}V)'</span>)
set(gca,<span class="string">'XTick'</span>,[], <span class="string">'YTick'</span>, [])
</pre><img vspace="5" hspace="5" src="acrss_trial_pli_tutorial_03.png" alt=""> <h2 id="9">Implement the across-trial phase-lag index.</h2><p>Now let's go ahead and implement the analyses. First, let's define an in-line function that calculates the phase-lag index. See Stam et al. (2007) for details: <a href="https://pubmed.ncbi.nlm.nih.gov/17266107/">https://pubmed.ncbi.nlm.nih.gov/17266107/</a></p><pre class="codeinput">pli_fx = @(phase_set_i,phase_set_j) abs(mean(sign(phase_set_i - phase_set_j),2));
</pre><p>Now let's test the function by calculating the across-trial PLI for channels i and j.</p><pre class="codeinput">i = 8;
j = 32;

phase_set_i = squeeze(xs.phase(i,:,:));
phase_set_j = squeeze(xs.phase(j,:,:));
</pre><p>Let's visualize the angular distribution of the phase differences between channels i and j at a single time-point.</p><pre class="codeinput"><span class="comment">% Calculate phase differences.</span>
phase_diffs = phase_set_i - phase_set_j;

<span class="comment">% Specify sample of interest.</span>
sample = 1000;

<span class="comment">% Plot</span>
figure;
polarhistogram(phase_diffs(sample,:),n_trials,<span class="string">'facecolor'</span>,<span class="string">'k'</span>)
title(<span class="string">'Phase differences'</span>)
</pre><img vspace="5" hspace="5" src="acrss_trial_pli_tutorial_04.png" alt=""> <p>The PLI value for this set of phase differences is:</p><pre class="codeinput">pli_fx(phase_set_i(sample,:),phase_set_j(sample,:))
</pre><pre class="codeoutput">
ans =

    0.1143

</pre><p>Now, let's run that calculation for all possible channel pairs, and track the output in the variable 'adjacency_tensor'.</p><pre class="codeinput">tic

adjacency_tensor = zeros(n_channels,n_channels,n_samples);
channel_pairs = nchoosek(1:n_channels,2);

<span class="keyword">for</span> ij = 1:length(channel_pairs)

    pair = channel_pairs(ij,:);
    pli = pli_fx(squeeze(xs.phase(pair(1),:,:)),squeeze(xs.phase(pair(2),:,:)));
    adjacency_tensor(pair(1),pair(2),:) = pli;

<span class="keyword">end</span>

<span class="comment">% Fill in symmetric values.</span>
<span class="keyword">for</span> sample = 1:n_samples
    adjacency_tensor(:,:,sample) = adjacency_tensor(:,:,sample)' + adjacency_tensor(:,:,sample);
<span class="keyword">end</span>

toc
</pre><pre class="codeoutput">Elapsed time is 27.300280 seconds.
</pre><p>The variable 'adjacency_tensor' is a 3 dimensional array with PLI adjacency matrices over time [Channel x Channel x Sample].</p><pre class="codeinput">fprintf(<span class="string">'\nDimensionality of adjacency tensor:'</span>)
disp(size(adjacency_tensor))
</pre><pre class="codeoutput">
Dimensionality of adjacency tensor:          64          64        6000

</pre><p>Let's plot the channel-by-channel adjacency matrix at a single time-point.</p><pre class="codeinput">figure;
imagesc(adjacency_tensor(:,:,1000))
colorbar
xlabel(<span class="string">'Channels'</span>)
ylabel(<span class="string">'Channels'</span>)
title(<span class="string">'Phase Lag Index'</span>)
</pre><img vspace="5" hspace="5" src="acrss_trial_pli_tutorial_05.png" alt=""> <p>Now let's see how to implement the same analyses using the function 'across_trial_pli.m'</p><pre class="codeinput">[adjacency_tensor, xs, filt_params] = across_trial_pli(xs.raw,samp_rate,filt_band);

<span class="comment">% Plot.</span>
figure;
imagesc(adjacency_tensor(:,:,1000))
colorbar
xlabel(<span class="string">'Channels'</span>)
ylabel(<span class="string">'Channels'</span>)
title(<span class="string">'Phase Lag Index'</span>)
</pre><pre class="codeoutput">
Calculating across-trial phase-lag index...
Elapsed time is 57.305452 seconds.
</pre><img vspace="5" hspace="5" src="acrss_trial_pli_tutorial_06.png" alt=""> <p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2022a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Across-trial phase-lag index: tutorial
% The following is a step-by-step tutorial demonstrating how the function
% 'across_trial_pli.m' is implemented. 

%% Generate pseudo EEG data.
% First, we will create pseudo-random EEG data. This data will be event-related (70 trials, 64 channels, 6000 samples per trial at a sampling rate of 1000Hz). 
% Each channel time-series will be a weighted combination of pink noise (i.e., 1/f) and
% two sinusoids (10Hz and 25Hz), where the phase of each sinusoid is drawn uniformly at random from -pi to pi.

% Define the dimensions of the data.
n_channels = 64;
n_samples = 6000;
n_trials = 70;
samp_rate = 1000;

% Define the frequencies and weights of the sinusoids.
peaks = [];
peaks.hz = [10,25];
peaks.w = [.1,.05];

% Define the amount of noise.
noise = 3;

% Set seed for reproducibility
rng(1)

xs = [];
xs.raw = zeros(n_channels,n_samples,n_trials);
time = 0:(1/samp_rate):(n_samples/samp_rate)-(1/samp_rate);

for trial = 1:n_trials
    for channel = 1:n_channels    
        sine_1 = sin(2*pi*peaks.hz(1)*time + rand(1)*pi);
        sine_2 = sin(2*pi*peaks.hz(2)*time + rand(1)*pi);         
        xs.raw(channel,:,trial) = peaks.w(1)*sine_1 + peaks.w(2)*sine_2;
    end
    xs.raw(:,:,trial) = xs.raw(:,:,trial) + noise*pinknoise(n_samples,n_channels)';
end

%%
% Let's have a look at the time-series of a single channel to ensure
% everything worked.

% Plot a single channel time-series.

figure('Position',[505 428 895 369]);
plot(xs.raw(1,:,1),'k');
xlim([650,1650])
ylim([-.5,.5])
xlabel('Time')
ylabel('Voltage ({\mu}V)')
title('Single channel time-series')
set(gca,'XTick',[], 'YTick', [])

%%
% Let's inpsect the power spectral density of said time-series as well, to ensure
% that the oscillations we created are present as peaks. With real data, I suggest
% parameterizing this power spectrum to assess the characteristics of any
% peaks that exist within the data prior to implementing these analyses. See,
% for example: https://fooof-tools.github.io/fooof/

[~,freq,~,psd] = spectrogram(xs.raw(1,:,1),samp_rate,[],[],samp_rate);
mean_psd = mean(psd,2);

figure('Position',[576 479 678 309]);
plot(freq,mean_psd,'k')
title('Power spectral density')
xlim([0,50])
ylim([0,.005])
xlabel('Hz')
ylabel('Power ({\mu}V{^2}/Hz)')
xline(peaks.hz,'REPLACE_WITH_DASH_DASH','color','red')
legend('PSD','Peaks')

%% Create filter.
% Now, let's create a band-pass filter so we can estimate the
% instantaneous phase of the oscillation at 10Hz. I'll use a window from
% 5-15Hz for this filter. However, visual inspection, as well as careful consideration of the research question (in terms of time/frequency resolution trade-off) is crucial in selecting this parameter.
% In an ideal world, the sensitivity of any results to a range of filter widths
% would be assessed.

filt_band = [5 15];  

filt_params = [];

filt_params.transition = mean(filt_band) * 0.2;                                                                   
filt_params.frequencies = [filt_band(1) - filt_params.transition, filt_band(1), filt_band(2), filt_band(2) + filt_params.transition];
filt_params.order = kaiserord(filt_params.frequencies, [0 1 0], [0.1 0.05 0.1], samp_rate);                                                                          
filt_params.coefficients = fir1(filt_params.order, filt_band*(2/samp_rate), 'bandpass');

%%
% The parameters of the filter are stored in the structure 'filt_params',
% shown here:
disp(filt_params)

%% Apply filter, estimate instantaneous phase.
% Now that we've created the filter, let's apply it and calculate the instantaenous phase of the time-series using the Hilbert transform. 
% First, we will Z-score each channel time-series, then filter, then calculate the instantaneous phase.

tic
for trial = 1:n_trials
   
    xs.norm(:,:,trial) = zscore(xs.raw(:,:,trial)')';
    
    for channel = 1:n_channels
        xs.filtered(channel,:,trial)  = filtfilt(filt_params.coefficients, 1, squeeze(xs.norm(channel,:,trial)));
    end

    xs.hilbert(:,:,trial) = hilbert(xs.filtered(:,:,trial));
    xs.phase(:,:,trial) = angle(xs.hilbert(:,:,trial));

end
toc

%%
% The structure 'xs' (time-series) includes all the intermediate processing steps: the raw signals, the z-scored signals, the band-pass filtered signals,
% the hilbert-transformed signals, and the instantaneous phase signals.

disp(xs)

%% 
% Let's plot the raw signal against the band-pass filtered signal to ensure
% everything worked correctly.

figure('Position',[505 428 895 369]);
plot(zscore(xs.raw(1,:,1)),'k')
hold on;plot(zscore(xs.filtered(1,:,1)),'color','red')
xlim([650,1650])
title('Raw vs. band-pass filtered signal')
legend('Raw','Filtered')
xlabel('Sample')
ylabel('Voltage ({\mu}V)')
set(gca,'XTick',[], 'YTick', [])

%% Implement the across-trial phase-lag index.
% Now let's go ahead and implement the analyses. First, let's define an in-line function that calculates the phase-lag index. See
% Stam et al. (2007) for details: https://pubmed.ncbi.nlm.nih.gov/17266107/

pli_fx = @(phase_set_i,phase_set_j) abs(mean(sign(phase_set_i - phase_set_j),2));

%%
% Now let's test the function by calculating the across-trial PLI for channels
% i and j.

i = 8;
j = 32;

phase_set_i = squeeze(xs.phase(i,:,:));
phase_set_j = squeeze(xs.phase(j,:,:));

%%
% Let's visualize the angular distribution of the phase differences between channels i and j at a single time-point.

% Calculate phase differences.
phase_diffs = phase_set_i - phase_set_j;

% Specify sample of interest.
sample = 1000;

% Plot
figure;
polarhistogram(phase_diffs(sample,:),n_trials,'facecolor','k')
title('Phase differences')

%%
% The PLI value for this set of phase differences is:

pli_fx(phase_set_i(sample,:),phase_set_j(sample,:))

%%
% Now, let's run that calculation for all possible channel pairs, and track
% the output in the variable 'adjacency_tensor'.

tic

adjacency_tensor = zeros(n_channels,n_channels,n_samples);
channel_pairs = nchoosek(1:n_channels,2);

for ij = 1:length(channel_pairs)
    
    pair = channel_pairs(ij,:);
    pli = pli_fx(squeeze(xs.phase(pair(1),:,:)),squeeze(xs.phase(pair(2),:,:)));
    adjacency_tensor(pair(1),pair(2),:) = pli;

end

% Fill in symmetric values.
for sample = 1:n_samples
    adjacency_tensor(:,:,sample) = adjacency_tensor(:,:,sample)' + adjacency_tensor(:,:,sample);
end

toc

%%
% The variable 'adjacency_tensor' is a 3 dimensional array with PLI adjacency matrices over time [Channel x Channel x Sample].

fprintf('\nDimensionality of adjacency tensor:')
disp(size(adjacency_tensor))

%%
% Let's plot the channel-by-channel adjacency matrix at a single
% time-point.
figure;
imagesc(adjacency_tensor(:,:,1000))
colorbar
xlabel('Channels')
ylabel('Channels')
title('Phase Lag Index')

%%
% Now let's see how to implement the same analyses using the function 'across_trial_pli.m'

[adjacency_tensor, xs, filt_params] = across_trial_pli(xs.raw,samp_rate,filt_band);

% Plot.
figure;
imagesc(adjacency_tensor(:,:,1000))
colorbar
xlabel('Channels')
ylabel('Channels')
title('Phase Lag Index')

##### SOURCE END #####
--></body></html>